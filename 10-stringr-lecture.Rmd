---
title: 'STAT 412/612 Class 16: Strings and RegEx'
author: "Kelsey Gonzalez"
date: "3/22/2021"
titlegraphic: "images/AU-Logo-on-white-small.png"
output: 
  pdf_document:
   toc: true
    number_sections:  true
  html_document: default

urlcolor: "blue"
header-includes:
- \usepackage{fancyhdr}
- \usepackage{lipsum}
- \pagestyle{fancy}
- \fancyhead[R]{\includegraphics{../AU-Logo-on-white-small.png}}
- \fancyhead[L]{WK2-Homework}
- \fancyfoot[L]{STAT 412/612}
- \fancyfoot[C]{\thepage}
- \fancypagestyle{plain}{\pagestyle{fancy}}
- \headheight=30pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE,
                      echo = TRUE,
                      message = FALSE, 
                      warning = FALSE)
```


# Working with Strings and Regular Expressions
Learning Outcomes

- Manipulate strings with the stringr package.
- Employ regular expressions (REGEX) to manipulate strings


## Lecture Notes
### Strings

- In R, strings (also called "characters") are created and displayed within quotes:

    ```{r}
    x <- "I am a string!"
    x
    ```

- Anything within quotes is a string, even numbers!
    ```{r, error=TRUE}
    y <- "3"
    class(y)
    ```

- You can have a vector of strings.

    ```{r}
    x <- c("I", "am", "a", "string", "vector")
    x[2:3]
    ```
    
- The backslash `"\"` means what is after the backslash is special in some way. 
- For example, if you want to put a quotation mark in a string, you can "escape" the quotation mark with a backslash.
  
    ```{r}
    x <- "As Tolkien said, \"Not all those who wander are lost\""
    writeLines(x)
    ```
    
- **`writeLines()` will print out the string itself.** 
- **`print()` will print out the printed representation** of the string (*with backslashes and all*).
  
    ```{r}
    print(x)
    ```
- **`"\n"`** represents a **new line**.

    ```{r}
    x <- "Not all those\nwho wander are lost."
    writeLines(x)
    ```
    
- **`"\t"`** represents a **tab**.

    ```{r}
    x <- "Not all those\twho wander are lost."
    writeLines(x)
    ```
    
- You can add any Unicode character with a `\u` followed by the hexadecimal 
  [unicode representation](https://en.wikipedia.org/wiki/List_of_Unicode_characters) of that character.
- Be careful about whether knitr will accept it though!
  
    ```{r}
    mu <- "\u00b5"
    writeLines(mu)
    
    writeLines(stringr::str_c("\u665a","\u4E0A","\u597D"))
    # http://pages.ucsd.edu/~dkjordan/resources/unicodemaker.html
    ```
  
### stringr Intro

- The stringr package has functions to make manipulating strings easier - (more user-friendly than base R's `grep()` and `gsub()`).
- stringr is part of the tidyverse so you do not have to load it separately.

    ```{r, message = FALSE}
    library(tidyverse)
    ```
    
- All of stringr's functions begin with "`str_`", so  in R Studio you can press tab after typing "`str_`" and a list of possible string manipulation functions will pop up (in RStudio).
  
- For example, use `str_length()` to get the number of characters in a string.

    ```{r}
    str_length(x <- "Upon the hearth the fire is red,")
    x
    ```
What about spaces and punctuation marks - they count!
What about escaped characters? The '\' does not but the character itself does.
    ```{r}
    str_length(x <- "Upon the hearth the fire is red,")
    str_length(x <- "Upon the hearth \nthe fire is red,")
    x
    ```


    ```{r}
    print(x)
    writeLines(x)
    ```


    ```{r}
    str_length(print(x))
    str_length(writeLines(x))
    str_length(factor("abc"))
    ```

#### Combining Strings with `str_c()`

- **Combine strings with `str_c()`**.
    ```{r}
    x <- "Faithless is he that says"
    y <- "farewell when the road darkens."
    str_c(x, y)
    ```

- The default is to separate strings by nothing, but you can **use `sep` to change the separator**.
    ```{r}
    str_c(x, y, sep = " ")
    ```
    
- Just like `c()`, `str_c()` can take multiple arguments.

    ```{r}
    str_c("Short", "cuts", "make", "long", "delays.", sep = " ")
    ```
    
- If you provide `str_c()` a vector of arguments, it will vectorize the combining unless you provide a `collapse` argument.
  
    ```{r}
    x <- c("Short", "cuts", "make", "long", "delays.")
    x
    str_c(x, "LOTR", sep = " ")
    str_c(x, collapse = " ")
    str_c(x, "LOTR", collapse = " ")
    ```

- Combining with `NA` results in `NA`:
    ```{r}
    str_c("Faithless is he that says", NA)
    ```
    

#### Extracting substrings with `str_sub()`, 

- **`str_sub()` extracts a substring** between the location of two characters.
    ```{r}
    x <- "The Road goes ever on and on"
    str_sub(x, start = 3, end = 6)
    ```
    
- Replace substrings with assignment
    ```{r}
    str_sub(x, start = 3, end = 6) <- " Tolkien "
    x
    ```
    
#####  **Exercise**: 
  - Reproduce this [quote](http://tolkiengateway.net/wiki/Ho!_Ho!_Ho!_To_the_Bottle_I_Go)

    > But under a tall tree I will lie  
      And let the clouds go sailing by.

    with these strings
    ```{r}
    w <- "But under a tall tree"
    x <- "FRELL I will lie"
    y <- "And let the clouds go"
    z <- "sailing by."
    ```
    
    ```{r}
    line1 <- str_c(w, str_sub(x, 6, str_length(x)))
    # or 
    # line1 <- str_c(w, str_sub(x, 7, str_length(x)), sep = " ")
    line2 <- str_c("\n",y)
    line2 <- str_c(line2, z, sep = " ")
    lines1_2 <- str_c(line1, line2)
    lines1_2
    writeLines(lines1_2)
    ```
    

### Regular Expressions

#### Intro

- Regular expressions (regex or regexp) are a syntax for **pattern matching** in strings.

- Regex structure is used in many different computer languages

- `str_replace()` and `str_replace_all()` search for a pattern as defined by the regex and then replace it (all) with another string.
  
- Wherever there is a `pattern` argument in a stringr function, you can use regex (to extract strings, get a logical if there is a match, etc...).
  
- regex includes special characters, e.g., "." and "\". These must be escaped using "\" if you want to match their normal value.

#### Regex using period `.` and backslash `\` in `str_replace_all()`

- Basic usage: find exact match of a string pattern and replace it with a designated string.

    ```{r}
    x <- "Ho! Ho! Ho! to the bottle I go to heal my heart and drown my woe."
    str_replace_all(x, "hea", "XX")
    ```

- A period **"`.`" matches any character**.

    ```{r}
    str_replace_all(x, "hea.", "XX")
    ```
    
- You can "escape" a period with two backslashes "`\\.`" to match periods.

    ```{r}
    str_replace_all(x, ".", "X") ## Matches everything
    str_replace_all(x, "\\.", "X") ## Matches the only period
    ```

- To match a backslash, you need four backslashes (to escape the escape).

    ```{r}
    y <- "Rain\\may\\fall\\and\\wind\\may\\blow"
    y
    str_length(y)
    writeLines(y)
    str_replace_all(y, "\\\\", "XX")
    ```


- *Important note*: Regular expressions are strings themselves. You can view them with `writeLines()`. 
- Using "`\\.`" as the pattern argument in R results in the regular expression "`\.`". `r writeLines("\\.")`

##### **Exercises**: 

1. Construct a regular expression to match this string (without the hashtags): 

    ```{r, eval = TRUE, echo = FALSE}
    writeLines("\\.\\.\\.")
    ```

    ```{r, eval = FALSE}
    writeLines("\\.\\.\\.")
    ```

2. Use one function call to replace `"back"` and `"lack"` with `"foo"` in the following.  
    ```{r, echo = TRUE}
    x <- "but better is Beer if drink we lack, and Water Hot poured down the back."
    ```

    ```{r}
    str_replace_all(x, ".ack", "foo")
    ```
    
#### Anchoring the regex so search starts at the beginning or at the end of a string

- You can anchor the regex pattern to begin looking for a match from the start (left-to-right) of the string or backwards from the end of a string (working-right to left).

    - `^` forces matching to begin **from the start** of a string.
    - `$` forces matching to begin **from the end** of a string.

    ```{r}
    x <- c("But", "under", "a", "tall", "tree", "I", "will", "lie")
    str_replace(x, "^t", "XX")
    str_replace(x, "t$", "XX")
    ```
    
- Use both to match only a complete string.

    ```{r}
    x <- c("apple pie", "apple", "apple cake")
    str_replace_all(x, "apple", "XX")
    str_replace_all(x, "^apple$", "XX")
    ```
    
##### **Exercise**: 
- Use `str_replace()` to replace all four letter words beginning with an `"a"` with `"foo"` in the following list:
    ```{r, echo = TRUE}
    x <- c("apple", "barn", "ape", "cart", "alas", "pain", "ally")
    ```
    
    ```{r}
    str_replace(x, "^a...$", "foo")
    ```
    
#### Special Characters

- We'll use this character vector for practice:
    ```{r}
    x <- c("Abba: 555-1234", "Anna: 555-0987", "Andy: 555-7654")
    ```

- `\\d`: **matches any digit.**
    ```{r}
    str_replace(x, "\\d\\d\\d-\\d\\d\\d\\d", "XXX-XXXX")
    ```

- `\\s`: **matches any white space** (e.g. space, tab, newline).
    ```{r}
    str_replace(x, "\\s", "X")
    ```

- `[abc]`: **matches `a`, `b`, or `c`**.
    ```{r}
    str_replace(x, "A[bn][bn]a", "XXXX")
    ```

- `[^abc]`: **matches anything except `a`, `b`, or `c`.**
- Note this is a different use of `^` since it is inside the `[ ]`
    ```{r}
    str_replace(x, "A[^b]", "XXXX")
    ```

- `abc|xyz`: matches either `abc` or `xyz`. This is called *alternation*
- You can use parentheses to control where the alternation occurs.
    - `a(bc|xy)z` matches either `abcz` or `axyz`.
    ```{r}
    str_replace(x, "An(na|dy)", "XXXX")
    ```

- To ignore case, place a `(?i)` before the regex.
    ```{r}
    str_replace("AB", "ab", "X")
    str_replace("AB", "(?i)ab", "X")
    ```

##### **Exercise**: 
- Create separate regular expressions to find all words that:

  1. Start with a vowel. Test on 
    ```{r}
    x1 <- c("abba", "cat", "eal", "ion", "oops", "Uganda", "Anna", "dog")
    ```

  2. That end in consonants. (Hint: thinking about matching "not"-vowels.) Test on
    ```{r}
    x2 <- c("bob", "Anna", "dog")
    ```

  3. End with `ed`, but not with `eed`. Test on
    ```{r}
    x3 <- c("tired", "need", "bad", "rod")
    ```
    
  4. End with `ing` or `ise`. Test on
    ```{r}
    x4 <- c("paradise", "firing", "jaded", "kin")
    ```
    
    ```{r}
    #1
    str_replace_all(x1, "^[aeiouAEIOU]", "XX")
    #2
    str_replace_all(x2, "[^aeiouAEIOU]$", "XX")
    #3
    str_replace(x3, "[^e]ed$", "XX")
    #4
    str_replace(x4, "(ing|ise)$", "XX")
    ```
    
#### Repetition using `?`, `+`, `*`, `{n}`, `{n,}`,`{0,n}`, `{n,m}`

- Can match a pattern multiple times in a row:
  - `?`: **0 or 1**
  - `+`: **1 or more**
  - `*`: **0 or more**
    
    ```{r}
    x <- c("A", "AA", "AAA", "AAAA", "B", "BB")
    str_replace_all(x, "^A?", "X")
    str_replace_all(x, "^A+", "X")
    str_replace_all(x, "^A*", "X")
    ```
    
- A more realistic example:
    ```{r}
    str_replace_all("color and colour", "colou?r", "X")
    ```

- **Control exactly how many repetitions** allowed in a match:

  - `{n}`: exactly `n`.
  - `{n,}`: `n` or more.
  - `{0,m}`: at most `m`.
  - `{n,m}`: between `n` and `m`.
  
    ```{r}
    str_replace_all(x, "A{2}", "X")
    str_replace_all(x, "A{2,}", "X")
    str_replace_all(x, "A{0,2}", "X")
    str_replace_all(x, "A{3,4}", "X")
    ```
    
- Regex will automatically match the longest string possible.

    ```{r}
    str_replace("AAAA", "A*", "X")
    ```
    
##### **Exercise**: 

- Create regular expressions to find all words with the following patterns and replace the patterns with "X":

  1. Start with three consonants. Test on
    ```{r}
    x1 <- c("string", "priority", "value", "distinction")
    ```
  2. Have three or more vowels in a row. Test on
    ```{r}
    x2 <- c("honorific", "delicious", "priority", "queueing")
    ```
  3. Have two or more vowel-consonant pairs in a row. Test on
    ```{r}
    x3 <- c("honorific", "sam", "prior")
    ```
    
    ```{r}
    str_replace_all(x1, "^[^aeiouAEIOU]{3}", "X")
    str_replace_all(x2, "[aeiouAEIOU]{3,}", "X")
    str_replace_all(x3, "([aeiouAEIOU][^aeiouAEIOU]){2,}", "X")
    ```
    
#### Grouping and Backreferences
  
- **Parentheses can also create a numbered group you can then back-reference** with `\\1` for the match in the first parentheses, `\\2` in the second parentheses, etc...

    ```{r}
    str_replace("cococola", "(..)", "pepsi-") 
    str_replace("cococola", "(..)\\1", "pepsi-")
    str_replace("cococola", "(..)\\1\\1", "pepsi-")
    str_replace("banana", "([aeiou][^aeiou])\\1", "-XX-")
    str_replace("banapa", "([aeiou][^aeiou])\\1", "-XX-")
    # show difference between pattern matching and repetition
    str_replace("banapa", "([aeiou][^aeiou])([aeiou][^aeiou])", "-XX-")
    
    str_replace("Mississippi", "(i)(s)\\2\\1\\2\\2","-X-") 
    #finds "ississ" and replaces  with XXXXXX
    ```


    ```{r}
    str_replace("Mississippi", "(i)(s)\\2\\1\\2\\2","-X\\1-") 
    # finds "ississ" and replaces it with "xi"
    ```


    ```{r}
    str_replace("Mississippi", "(i)(s)\\2\\1\\2\\2","-X\\2-") 
    # finds "ississ" and replaces it with "Xs"
    ```


    ```{r}
    str_replace("Mississippi","(i)(s)\\2\\1\\2\\2","-\\2\\1\\1\\2\\1\\1-") 
    # finds "ississ" and replaces with "siisii" 
    ```

### `stringr` has functions to do more than replace

- There are a lot of functions to analyze, compare and adjust strings.

#### Changing Case 
  
- `str_to_lower()` and `str_to_upper()` **convert all letters to lower or capital case**.
    ```{r}
    x <- "Deeds will not be less valiant because they are unpraised."
    str_to_lower(x)
    str_to_upper(x)
    ```

- `str_to_sentence` **converts all words and letters to sentence case**. Includes Acronyms
    ```{r}
    x2 <- "Deeds will Not be LESS vaLiant because THey are unpraised."
    str_to_sentence(x2)
    str_to_upper(x2)
    str_to_sentence(str_to_upper(x2))
    ```

#### Detecting matches

- `str_detect()`: **Returns `TRUE` if a regex pattern matches a string and `FALSE` if it does not.** Very useful for filters.

  
    ```{r, message = FALSE}
#### Get all John's and Joe's from the Lahman dataset
    library(Lahman)
    data("Master")
```

    ```{r}
      Master %>%
      filter(str_detect(nameFirst, "^Jo(e|hn)$")) %>%
      select(nameFirst, nameLast) %>% 
      head()->
      masterj
    print(masterj)
    
    ```
  
- `str_subset()`: **Returns the words where there is a match**. Not as commonly used as `str_detect()` because we don't use it much to manipulate data frames.
  
    ```{r}
    str_subset(Master$nameFirst, "^Jo(e|hn)$") %>%
      head()
    ```

#### Counting Matches

- `str_count()`: **Counts the occurrence of a match within a string**.

    ```{r}
    str_count(c("banana", "coco"), "[^aeiou][aeiou]")
    ```
    
- It counts *non-overlapping* matches
    
    ```{r}
    str_count("abababa", "aba")
    ```
  
#### Extracting Matches

- `str_extract()` returns *the first match* for pattern.
- `str_extract_all()`  returns *all matches* but as a list.
    ```{r}
    colorstr <- str_c("red", "blue", "yellow", "orange", "brown", sep = "|")
    colorstr
    a <- str_extract("I like blue and brown and that's it", colorstr)
    b <- str_extract_all("I like blue and brown and that's it", colorstr)
    a
    str(a)
    b
    str(b)
    ```

- `str_match()`: returns *a matrix* where each column is a grouped component.

    ```{r}
    x <- "I like blue and brown and that's it, or black"
    str_extract_all(x, "(and|or)\\s([^\\s]+)")
    str_match_all(x, "(and|or)\\s([^\\s]+)")
    ```

#### Splitting Strings or Replacing Strings

- Let's look at the poem ["Farewell We Call to Hearth and Hall!"](http://tolkiengateway.net/wiki/Farewell_We_Call_to_Hearth_and_Hall!)
    ```{r}
    farewell <- c("Farewell we call to hearth and hall! \nThough wind may blow and rain may fall,\nWe must away ere break of day\nFar over wood and mountain tall.")
    writeLines(farewell)
    ```

- `str_split()` will **split up a string** based on a character we choose;  useful with dates or full names at times

    ```{r}
    ## Split based on spaces
    str_split(farewell, pattern = "\\s+", simplify = TRUE) ## use one or more space to split
    ```
    
- `str_replace()` and `str_replace_all()` will replace patterns with provided strings. So say we want to get rid of all punctuation.
  
    ```{r}
    str_split(farewell, pattern = "\\s+", simplify = TRUE) %>%
      str_replace_all("\\.|\\!|,", "")
    ```
    
- You can use back references to populate the replacement.

    ```{r}
    str_replace_all("It is 1am", "(\\d+)(am|pm)", "2\\2")
    ```

- More stringr options can be found in [RDS](https://r4ds.had.co.nz/).


## References 
Wickham and Grolemund. 2016. _R for data science_ O'Reilly Media, Inc. 
* [Chapter 14](https://r4ds.had.co.nz/workflow-projects.html)
- [Work with Strings Cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf).
    - [Stringr Overview](https://stringr.tidyverse.org/).
